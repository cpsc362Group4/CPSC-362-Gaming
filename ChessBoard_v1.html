<!-- Jonnathan Quijada -->
<!-- This Code was generated by Ai -->
 <!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Chess with AI (Minimax)</title>
<style>
    body {
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        background: #333;
        margin: 0;
        font-family: Arial;
    }
    #board {
        width: 480px;
        height: 480px;
        display: grid;
        grid-template-columns: repeat(8, 1fr);
        grid-template-rows: repeat(8, 1fr);
        border: 5px solid #222;
    }
    .square {
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 40px;
        user-select: none;
        position: relative;
    }
    .white { background: #eee; }
    .black { background: #6b8e23; }
    .highlight { outline: 3px solid yellow; }
    .move-dot {
        position: absolute;
        width: 16px;
        height: 16px;
        background: rgba(0,0,0,0.5);
        border-radius: 50%;
        pointer-events: none;
    }
    .piece { cursor: grab; }
</style>
</head>
<body>

<div id="board"></div>

<script>
// ------------------ Chess Constants ------------------
const PIECE_SYMBOLS = {
    "r":"♜","n":"♞","b":"♝","q":"♛","k":"♚","p":"♟",
    "R":"♖","N":"♘","B":"♗","Q":"♕","K":"♔","P":"♙"
};

let board = [
    "r","n","b","q","k","b","n","r",
    "p","p","p","p","p","p","p","p",
    "","","","","","","","",
    "","","","","","","","",
    "","","","","","","","",
    "","","","","","","","",
    "P","P","P","P","P","P","P","P",
    "R","N","B","Q","K","B","N","R"
];

// Track turns (White = human, Black = AI)
let whiteToMove = true;

const boardDiv = document.getElementById("board");

let selectedSq = null;
let legalMoves = [];
let draggedPiece = null;
let dragStart = null;

// ------------------ Drawing the Board ------------------
function drawBoard() {
    boardDiv.innerHTML = "";
    for (let i = 0; i < 64; i++) {
        const sq = document.createElement("div");
        const row = Math.floor(i / 8);
        const col = i % 8;

        sq.classList.add("square", ((row + col) % 2 === 0) ? "white" : "black");
        sq.dataset.index = i;

        let piece = board[i];
        if (piece) {
            const el = document.createElement("div");
            el.textContent = PIECE_SYMBOLS[piece];
            el.classList.add("piece");
            el.draggable = true;

            el.addEventListener("dragstart", onDragStart);
            el.addEventListener("dragend", onDragEnd);

            sq.appendChild(el);
        }

        sq.addEventListener("click", onSquareClick);
        sq.addEventListener("dragover", e => e.preventDefault());
        sq.addEventListener("drop", onDrop);

        boardDiv.appendChild(sq);
    }
}

// ------------------ Move Generation ------------------
function getLegalMoves(index, boardState=board) {
    const piece = boardState[index];
    if (!piece) return [];

    const isWhite = piece === piece.toUpperCase();
    const r = Math.floor(index / 8);
    const c = index % 8;
    const moves = [];

    function add(rr, cc) {
        if (rr < 0 || rr >= 8 || cc < 0 || cc >= 8) return;
        const i = rr * 8 + cc;
        if (!boardState[i] || isWhite !== (boardState[i] === boardState[i].toUpperCase()))
            moves.push(i);
    }

    function ray(dr, dc) {
        let rr = r + dr, cc = c + dc;
        while (rr >= 0 && rr < 8 && cc >= 0 && cc < 8) {
            let i = rr * 8 + cc;
            if (!boardState[i]) moves.push(i);
            else {
                if (isWhite !== (boardState[i] === boardState[i].toUpperCase()))
                    moves.push(i);
                break;
            }
            rr += dr; cc += dc;
        }
    }

    switch (piece.toLowerCase()) {
        case "p": {
            const dir = isWhite ? -1 : 1;
            const startRow = isWhite ? 6 : 1;

            // forward
            if (!boardState[(r + dir) * 8 + c]) {
                moves.push((r + dir) * 8 + c);
                if (r === startRow && !boardState[(r + 2 * dir) * 8 + c])
                    moves.push((r + 2 * dir) * 8 + c);
            }

            // captures
            for (let dc of [-1,1]) {
                const rr = r + dir, cc = c + dc;
                if (rr >= 0 && rr < 8 && cc >= 0 && cc < 8) {
                    const i = rr * 8 + cc;
                    if (boardState[i] && (isWhite !== (boardState[i] === boardState[i].toUpperCase())))
                        moves.push(i);
                }
            }
            break;
        }
        case "r": ray(1,0); ray(-1,0); ray(0,1); ray(0,-1); break;
        case "b": ray(1,1); ray(1,-1); ray(-1,1); ray(-1,-1); break;
        case "q": ray(1,0); ray(-1,0); ray(0,1); ray(0,-1);
                  ray(1,1); ray(1,-1); ray(-1,1); ray(-1,-1); break;
        case "n":
            [[1,2],[1,-2],[-1,2],[-1,-2],[2,1],[2,-1],[-2,1],[-2,-1]]
            .forEach(([dr,dc]) => add(r+dr, c+dc));
            break;
        case "k":
            for (let dr=-1; dr<=1; dr++)
                for (let dc=-1; dc<=1; dc++)
                    if (dr || dc) add(r+dr, c+dc);
    }

    return moves;
}

// ------------------ Highlights ------------------
function clearHighlights() {
    document.querySelectorAll(".highlight").forEach(s=>s.classList.remove("highlight"));
    document.querySelectorAll(".move-dot").forEach(dot=>dot.remove());
}

function highlightMoves(moves) {
    moves.forEach(i => {
        const sq = boardDiv.children[i];
        sq.classList.add("highlight");

        const dot = document.createElement("div");
        dot.classList.add("move-dot");
        sq.appendChild(dot);
    });
}

// ------------------ Click Moves (Human) ------------------
function onSquareClick(e) {
    if (!whiteToMove) return; // AI's turn

    const index = parseInt(e.currentTarget.dataset.index);

    if (selectedSq === null) {
        if (board[index] && board[index] === board[index].toUpperCase()) {
            selectedSq = index;
            legalMoves = getLegalMoves(index);
            clearHighlights();
            highlightMoves(legalMoves);
        }
        return;
    }

    if (legalMoves.includes(index)) {
        board[index] = board[selectedSq];
        board[selectedSq] = "";
        finishHumanMove();
        return;
    }

    if (board[index] && board[index] === board[index].toUpperCase()) {
        selectedSq = index;
        legalMoves = getLegalMoves(index);
        clearHighlights();
        highlightMoves(legalMoves);
    }
}

// ------------------ Drag & Drop ------------------
function onDragStart(e) {
    if (!whiteToMove) { e.preventDefault(); return; }
    draggedPiece = e.target;
    dragStart = parseInt(e.target.parentElement.dataset.index);
    selectedSq = dragStart;
    legalMoves = getLegalMoves(dragStart);
    clearHighlights();
    highlightMoves(legalMoves);
}

function onDragEnd() {
    draggedPiece = null;
    dragStart = null;
    selectedSq = null;
    legalMoves = [];
    clearHighlights();
}

function onDrop(e) {
    if (!whiteToMove) return;

    const dropIndex = parseInt(e.currentTarget.dataset.index);
    if (legalMoves.includes(dropIndex)) {
        board[dropIndex] = board[dragStart];
        board[dragStart] = "";
        finishHumanMove();
    }
}

// ------------------ Human move finishes; AI plays ------------------
function finishHumanMove() {
    clearHighlights();
    drawBoard();
    whiteToMove = false;
    setTimeout(aiMove, 200); // small delay
}

// ------------------ Evaluation (Material only) ------------------
const pieceValue = { "p":1, "n":3, "b":3, "r":5, "q":9, "k":200 };

function evaluate(boardState) {
    let score = 0;
    for (let piece of boardState) {
        if (!piece) continue;
        const val = pieceValue[piece.toLowerCase()];
        if (!val) continue;
        score += (piece === piece.toUpperCase()) ? val : -val;
    }
    return score;
}

// ------------------ Minimax + Alpha-Beta ------------------
function minimax(boardState, depth, alpha, beta, maximizingPlayer) {
    if (depth === 0) return [evaluate(boardState), null];

    // Generate all moves for the side to move
    let bestMove = null;
    let bestScore = maximizingPlayer ? -9999 : 9999;

    for (let i = 0; i < 64; i++) {
        let piece = boardState[i];
        if (!piece) continue;

        const isWhitePiece = piece === piece.toUpperCase();
        if (maximizingPlayer !== isWhitePiece) continue;

        const moves = getLegalMoves(i, boardState);

        for (let m of moves) {
            const newBoard = boardState.slice();
            newBoard[m] = piece;
            newBoard[i] = "";

            const [score] = minimax(newBoard, depth - 1, alpha, beta, !maximizingPlayer);

            if (maximizingPlayer) {
                if (score > bestScore) { bestScore = score; bestMove = [i, m]; }
                alpha = Math.max(alpha, score);
            } else {
                if (score < bestScore) { bestScore = score; bestMove = [i, m]; }
                beta = Math.min(beta, score);
            }
            if (beta <= alpha) return [bestScore, bestMove];
        }
    }

    return [bestScore, bestMove];
}

// ------------------ AI Move ------------------
function aiMove() {
    const [score, move] = minimax(board, 3, -99999, 99999, false); // black = minimizing

    if (!move) {
        alert("Game over!");
        return;
    }

    const [from, to] = move;
    board[to] = board[from];
    board[from] = "";

    whiteToMove = true;
    drawBoard();
}

// ------------------ Init ------------------
drawBoard();
</script>

</body>
</html>
