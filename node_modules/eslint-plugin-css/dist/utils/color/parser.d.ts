import postcssValueParser from "postcss-value-parser";
import type { Unit } from "./data";
export declare class FunctionArgument {
    private readonly raws;
    readonly node: postcssValueParser.Node;
    constructor(before: string, node: postcssValueParser.Node, after?: string);
    toString(): string;
}
export type AlphaArgument = AlphaArgumentValid | AlphaArgumentInvalid;
export declare abstract class AbsAlphaArgument<V extends number | null> {
    private readonly div;
    private readonly tokens;
    readonly value: V;
    constructor(div: FunctionArgument, tokens: FunctionArgument[], alpha: V);
    toAlphaString(): string;
    toString(): string;
}
export declare class AlphaArgumentValid extends AbsAlphaArgument<number> {
    get valid(): true;
}
export declare class AlphaArgumentInvalid extends AbsAlphaArgument<number | null> {
    get valid(): false;
}
export type NumberWithUnit<U extends Unit> = {
    number: number;
    unit: U;
};
export type ValuesArgument<V> = ValuesArgumentComplete<V> | ValuesArgumentIncomplete;
declare abstract class AbsValuesArgument<V> {
    private readonly tokens;
    readonly value: V;
    constructor(tokens: FunctionArgument[], value: V);
    toString(): string;
}
export declare class ValuesArgumentComplete<V> extends AbsValuesArgument<V> {
    readonly complete = true;
}
export declare class ValuesArgumentIncomplete extends AbsValuesArgument<null> {
    readonly complete = false;
    constructor(tokens: FunctionArgument[]);
}
export declare function parseFunction(input: string | postcssValueParser.Node, expectName: string | string[]): null | {
    rawName: string;
    arguments: FunctionArgument[];
};
export declare function parseNumberUnit<U extends Unit>(input: FunctionArgument | undefined, expectUnits: U[]): NumberWithUnit<U> | null;
export declare function parseInput(input: string | postcssValueParser.Node | undefined): postcssValueParser.Node | null;
export declare function isPercentRange(node: NumberWithUnit<"" | "%"> | null): node is NumberWithUnit<"" | "%">;
type ParseArgumentValuesOption<V> = {
    generate: (args: FunctionArgument[]) => V | null;
};
type ParseArgumentValuesWithCommaOption<V> = ParseArgumentValuesOption<V> & {
    argCount: number;
};
export declare function parseArgumentValues<V>(functionArguments: FunctionArgument[], option: ParseArgumentValuesWithCommaOption<V>): {
    values: ValuesArgument<V>;
    alpha: AlphaArgument | null;
};
export declare function parseArgumentValuesWithSpace<V>(functionArguments: FunctionArgument[], option: ParseArgumentValuesOption<V>): {
    values: ValuesArgument<V>;
    alpha: AlphaArgument | null;
};
export declare function parseArgumentValuesWithComma<V>(functionArguments: FunctionArgument[], option: ParseArgumentValuesWithCommaOption<V>): {
    values: ValuesArgument<V>;
    alpha: AlphaArgument | null;
};
export {};
